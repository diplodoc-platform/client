import type {Compiler} from '@rspack/core';

import path from 'node:path';
import {createHash} from 'node:crypto';
import rtlcss from 'rtlcss';

const checkIsCss = (filename: string) => path.extname(filename) === '.css';

type Options = {
    filename?: string | string[];
    options?: rtlcss.ConfigOptions;
    plugins?: rtlcss.Plugin[];
    hooks?: rtlcss.HookOptions;
};

export class RtlCssPlugin {
    readonly options: Options;

    constructor(options: Options) {
        this.options = {
            filename: '[name].rtl.css',
            options: {},
            plugins: [],
            hooks: {},
            ...options,
        };
    }

    apply(compiler: Compiler) {
        const {Compilation, sources} = compiler.webpack;

        compiler.hooks.compilation.tap('RtlCssPlugin', (compilation) => {
            compilation.hooks.processAssets.tap(
                {
                    name: 'RtlCssPlugin-processing',
                    stage: Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE,
                },
                (assets) => {
                    compilation.chunks.forEach((chunk) => {
                        Array.from(chunk.files)
                            .filter(checkIsCss)
                            .forEach((filename) => {
                                // Get the asset source for each file generated by the chunk:
                                const assetSource = assets[filename].source().toString();
                                const processedAssetSource = rtlcss.process(
                                    assetSource,
                                    this.options.options,
                                    this.options.plugins,
                                    this.options.hooks,
                                );

                                let interpolatedFilePath;

                                if (Array.isArray(this.options.filename)) {
                                    if (this.options.filename.length !== 2) {
                                        throw Error('You should pass two elements and array');
                                    }
                                    // also allow save current file destination
                                    interpolatedFilePath = filename.replace(
                                        this.options.filename[0],
                                        this.options.filename[1],
                                    );
                                } else {
                                    const hash = createHash('sha256');
                                    hash.update(processedAssetSource);

                                    interpolatedFilePath = compilation.getPath(
                                        this.options.filename ?? '',
                                        {
                                            contentHash: hash.digest('hex').slice(0, 16),
                                            chunk,
                                        },
                                    );
                                }

                                compilation.emitAsset(
                                    interpolatedFilePath,
                                    new sources.RawSource(processedAssetSource),
                                );
                            });
                    });
                },
            );
        });
    }
}
